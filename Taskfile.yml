version: "3"

vars:
  ARGOCD_NAMESPACE: argocd

tasks:
  build:
    desc: "Create K3D cluster with LoadBalancer port mapping"
    cmds:
      - k3d cluster create --api-port 6550 -p "8080:80@loadbalancer" --agents 2
      - echo "Cluster created successfully"

  # ArgoCD Installation
  deploy-argocd:
    desc: "Deploy ArgoCD"
    cmds:
      - "kubectl create namespace {{.ARGOCD_NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -"
      - "kubectl apply -n {{.ARGOCD_NAMESPACE}} -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml"
      - echo "Waiting for ArgoCD deployment to be ready..."
      - "kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n {{.ARGOCD_NAMESPACE}}"
      - 'kubectl patch svc argocd-server -n {{.ARGOCD_NAMESPACE}} --type=merge --patch="{\"spec\":{\"type\":\"LoadBalancer\"}}"'

  # Direkte Deployments (OHNE ArgoCD) mit Kustomize
  deploy-dev:
    desc: "Deploy to Development environment (Helm + Kustomize)"
    cmds:
      - >
        helm upgrade --install nginx-demo-dev nginx-demo/
        --namespace dev
        --create-namespace
        --set argocd.enabled=false
        --post-renderer ./kustomize-post-renderer.sh
        --post-renderer-args overlays/dev

  deploy-stage:
    desc: "Deploy to Staging environment (Helm + Kustomize)"
    cmds:
      - >
        helm upgrade --install nginx-demo-stage nginx-demo/
        --namespace stage
        --create-namespace
        --set argocd.enabled=false
        --post-renderer ./kustomize-post-renderer.sh
        --post-renderer-args overlays/stage

  deploy-prod:
    desc: "Deploy to Production environment (Helm + Kustomize)"
    cmds:
      - >
        helm upgrade --install nginx-demo-prod nginx-demo/
        --namespace prod
        --create-namespace
        --set argocd.enabled=false
        --post-renderer ./kustomize-post-renderer.sh
        --post-renderer-args overlays/prod

  # ArgoCD Application Deployments (NUR Applications, keine Workloads)
  deploy-argo-dev:
    desc: "Deploy Development ArgoCD Application"
    cmds:
      - >
        helm upgrade --install nginx-demo-dev-argo nginx-demo/
        --namespace argocd
        --set argocd.enabled=true
        --set argocd.appName=nginx-demo-dev
        --set argocd.source.repoURL=https://github.com/maxhaeger/helm-kustomize-demo.git
        --set argocd.source.targetRevision=master
        --set argocd.destination.namespace=dev
        --set argocd.syncPolicy.automated.prune=true
        --set argocd.syncPolicy.automated.selfHeal=true
      - echo "‚úÖ ArgoCD Application for DEV created"

  deploy-argo-stage:
    desc: "Deploy Staging ArgoCD Application"
    cmds:
      - >
        helm upgrade --install nginx-demo-stage-argo nginx-demo/
        --namespace argocd
        --set argocd.enabled=true
        --set argocd.appName=nginx-demo-stage
        --set argocd.source.repoURL=https://github.com/maxhaeger/helm-kustomize-demo.git
        --set argocd.source.targetRevision=master
        --set argocd.destination.namespace=stage
        --set argocd.syncPolicy.automated.prune=false
        --set argocd.syncPolicy.automated.selfHeal=true
      - echo "‚úÖ ArgoCD Application for STAGE created"

  deploy-argo-prod:
    desc: "Deploy Production ArgoCD Application"
    cmds:
      - >
        helm upgrade --install nginx-demo-prod-argo nginx-demo/
        --namespace argocd
        --set argocd.enabled=true
        --set argocd.appName=nginx-demo-prod
        --set argocd.source.repoURL=https://github.com/maxhaeger/helm-kustomize-demo.git
        --set argocd.source.targetRevision=master
        --set argocd.destination.namespace=prod
        --set argocd.syncPolicy.automated.prune=false
        --set argocd.syncPolicy.automated.selfHeal=false
      - echo "‚úÖ ArgoCD Application for PROD created"

  deploy-all-argo-apps:
    desc: "Deploy ArgoCD Applications for all environments"
    cmds:
      - task: deploy-argo-dev
      - task: deploy-argo-stage
      - task: deploy-argo-prod

  argo-status:
    desc: "Check all ArgoCD applications status"
    cmds:
      - echo "=== ArgoCD Applications ==="
      - kubectl get applications -n argocd -o wide

  sync-all:
    desc: "Sync all ArgoCD applications"
    cmds:
      - kubectl patch application nginx-demo-dev -n argocd --type=merge -p='{"operation":{"sync":{}}}'
      - kubectl patch application nginx-demo-stage -n argocd --type=merge -p='{"operation":{"sync":{}}}'
      - kubectl patch application nginx-demo-prod -n argocd --type=merge -p='{"operation":{"sync":{}}}'

  publish:
    desc: "Port-forward ArgoCD UI"
    cmds:
      - "kubectl port-forward svc/argocd-server -n {{.ARGOCD_NAMESPACE}} 8081:80"

  argo-secret-copy:
    desc: "Copy ArgoCD admin password to clipboard"
    cmds:
      - 'kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d | pbcopy'
      - echo "‚úÖ ArgoCD admin password copied to clipboard"

  # Monitoring Setup
  setup-monitoring:
    desc: "Setup Helm repositories for monitoring"
    cmds:
      - helm repo add elastic https://helm.elastic.co
      - helm repo add fluent https://fluent.github.io/helm-charts
      - helm repo add grafana https://grafana.github.io/helm-charts
      - helm repo update
      - echo "‚úÖ Monitoring repositories added"

  deploy-elasticsearch:
    desc: "Deploy Elasticsearch"
    deps: [setup-monitoring]
    cmds:
      - >
        helm upgrade --install elasticsearch elastic/elasticsearch
        --namespace logging
        --create-namespace
        --set replicas=1
        --set minimumMasterNodes=1
        --set resources.requests.cpu="100m"
        --set resources.requests.memory="512Mi"
        --set resources.limits.cpu="1000m"
        --set resources.limits.memory="2Gi"
        --set persistence.enabled=false
        --set antiAffinity="soft"

  deploy-kibana:
    desc: "Deploy Kibana"
    deps: [deploy-elasticsearch]
    cmds:
      - >
        helm upgrade --install kibana elastic/kibana
        --namespace logging
        --set resources.requests.cpu="100m"
        --set resources.requests.memory="512Mi"
        --set service.type=LoadBalancer

  deploy-fluent-bit:
    desc: "Deploy Fluent Bit"
    deps: [deploy-elasticsearch]
    cmds:
      - >
        helm upgrade --install fluent-bit fluent/fluent-bit
        --namespace logging
        --set config.outputs[0].name=es
        --set config.outputs[0].match="kube.*"
        --set config.outputs[0].host=elasticsearch-master.logging.svc.cluster.local
        --set config.outputs[0].port=9200
        --set config.outputs[0].index=fluent-bit
        --set config.outputs[0].logstash_format=true
        --set config.outputs[0].logstash_prefix=kubernetes
        --set config.outputs[0].retry_limit=false

  monitoring:
    desc: "Deploy complete ELK + Fluent Bit monitoring stack"
    cmds:
      - task: setup-monitoring
      - task: deploy-elasticsearch
      - task: deploy-kibana
      - task: deploy-fluent-bit
      - echo ""
      - echo "üéâ Monitoring stack deployed successfully!"

  # Alternative: Grafana Loki Stack (leichtgewichtiger)
  monitoring-loki:
    desc: "Deploy Grafana Loki stack (lightweight alternative)"
    cmds:
      - helm repo add grafana https://grafana.github.io/helm-charts
      - helm repo update
      - >
        helm upgrade --install loki grafana/loki-stack
        --namespace logging
        --create-namespace
        --set grafana.enabled=true
        --set prometheus.enabled=true
        --set fluent-bit.enabled=true
        --set grafana.service.type=LoadBalancer
      - echo "‚úÖ Loki stack deployed"

  monitoring-status:
    desc: "Check monitoring stack status"
    cmds:
      - echo "=== Elasticsearch Status ==="
      - kubectl get pods -l app=elasticsearch-master -n logging
      - echo ""
      - echo "=== Kibana Status ==="
      - kubectl get pods -l app=kibana -n logging
      - echo ""
      - echo "=== Fluent Bit Status ==="
      - kubectl get pods -l app.kubernetes.io/name=fluent-bit -n logging
      - echo ""
      - echo "=== Services ==="
      - kubectl get svc -n logging

  monitoring-logs:
    desc: "Show logs from monitoring components"
    cmds:
      - echo "=== Elasticsearch Logs ==="
      - kubectl logs -l app=elasticsearch-master -n logging --tail=20 || echo "No Elasticsearch logs"
      - echo ""
      - echo "=== Fluent Bit Logs ==="
      - kubectl logs -l app.kubernetes.io/name=fluent-bit -n logging --tail=20 || echo "No Fluent Bit logs"

  kibana-access:
    desc: "Port-forward to access Kibana UI"
    cmds:
      - echo "üåê Opening Kibana on http://localhost:5601"
      - echo "üí° Create index pattern 'kubernetes-*' with time field '@timestamp'"
      - kubectl port-forward svc/kibana-kibana 5601:5601 -n logging

  elasticsearch-test:
    desc: "Test Elasticsearch connectivity"
    cmds:
      - echo "üîç Testing Elasticsearch health..."
      - kubectl port-forward svc/elasticsearch-master 9200:9200 -n logging &
      - sleep 5
      - curl -s http://localhost:9200/_cluster/health?pretty || echo "‚ùå Elasticsearch not accessible"
      - curl -s http://localhost:9200/_cat/indices?v || echo "‚ùå No indices found yet"
      - pkill -f "port-forward.*9200" || true

  clean-monitoring:
    desc: "Remove monitoring stack"
    cmds:
      - helm uninstall fluent-bit -n logging --ignore-not-found
      - helm uninstall kibana -n logging --ignore-not-found
      - helm uninstall elasticsearch -n logging --ignore-not-found
      - kubectl delete namespace logging --ignore-not-found
      - echo "‚úÖ Monitoring stack removed"

  # Debugging und Testing
  test-logs:
    desc: "Generate test logs and check monitoring"
    cmds:
      - echo "üß™ Deploying test application..."
      - task: deploy-dev
      - echo "üìä Generating test traffic..."
      - kubectl port-forward svc/nginx-service 8080:80 -n dev &
      - sleep 3
      - for i in {1..20}; do curl -s http://localhost:8080/ > /dev/null; echo "Request $i sent"; sleep 1; done
      - pkill -f "port-forward.*8080" || true
      - echo "‚úÖ Test traffic generated. Check Kibana for logs!"

  setup-complete:
    desc: "Complete setup with cluster, ArgoCD, and monitoring"
    cmds:
      - task: build
      - task: deploy-argocd
      - task: monitoring
      - echo ""
      - echo "üéâ Complete setup finished!"

  clean:
    desc: "Clean up everything"
    cmds:
      - k3d cluster delete
      - rm -rf tmp/
